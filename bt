#!/usr/bin/env python3
#-----------------------------------------------------------------------------------------------------------------------
# bt is part of Brewken, and is copyright the following authors 2022-2023:
#   • Matt Young <mfsy@yahoo.com>
#
# Brewken is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Brewken is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# This build tool (bt) script helps with Git setup, meson build configuration and packaging.  It takes one argument, and
# does different things depending on what that argument is:
#
#    ./bt setup                  Sets up Git options and configures the 'mbuild' meson build directory
#
#    ./bt setup all              As above but also tries to install all tools and dependencies we need
#
#    ./bt package                Does the packaging.  First runs 'meson install' (with extra options to "install"
#                                binaries, data etc to a subdirectory of the build directory rather than to where they
#                                need to be for a local install).  Then creates a distributable package, making use
#                                of various build variables passed back from Meson.
#
#
#
# .:TODO:. At some point we should be able to retire:
#    configure
#    setupgit.sh
#    CMakeLists.txt
#    src/CMakeLists.txt
#    packaging/qtIfw -- if we end up not going with Qt Install Framework
#
#
# Note that Python allows both single and double quotes for delimiting strings.  In Meson, we need single quotes, in
# C++, we need double quotes.  We mostly try to use single quotes below for consistency with Meson, except where using
# double quotes avoids having to escape a single quote.
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# Python built-in modules we use
#-----------------------------------------------------------------------------------------------------------------------
import argparse
import datetime
import glob
import logging
import os
import pathlib
import platform
import re
import shutil
import subprocess
import sys
import tempfile
from decimal import Decimal

#-----------------------------------------------------------------------------------------------------------------------
# Global constants
#-----------------------------------------------------------------------------------------------------------------------
projectName = 'brewken'
capitalisedProjectName = projectName.capitalize()
projectUrl = 'https://github.com/' + capitalisedProjectName + '/' + projectName + '/'

#-----------------------------------------------------------------------------------------------------------------------
# Welcome banner and environment info
#-----------------------------------------------------------------------------------------------------------------------
# The '%c' argument to strftime means "Locale’s appropriate date and time representation"
print(
   '⭐ ' + capitalisedProjectName + ' build tool running on ' + platform.system() + ' (' + platform.release() +
   '), using Python ' + platform.python_version() + ', at ' + datetime.datetime.now().strftime('%c') + ' ⭐'
)

#-----------------------------------------------------------------------------------------------------------------------
# Set up logging to stderr
#-----------------------------------------------------------------------------------------------------------------------
logging.basicConfig(format='%(message)s')
log = logging.getLogger(__name__)
# This is our default log level, but it can be overridden via the -v and -q command line options -- see below
log.setLevel(logging.INFO)
# Include the log level in the message
handler = logging.StreamHandler()
handler.setFormatter(
   # You can add timestamps etc to logs, but that's overkill for this script.  Source file location of log message is
   # however pretty useful for debugging.
   logging.Formatter('{levelname:s}:  {message}  [{filename:s}:{lineno:d}]', style='{')
)
log.addHandler(handler)
# If we don't do this, everything gets printed twice
log.propagate = False

#-----------------------------------------------------------------------------------------------------------------------
# Python 3rd-party modules we use
#-----------------------------------------------------------------------------------------------------------------------
# Per https://docs.python.org/3/library/ensurepip.html, the official way to ensure Pip is installed and at the latest
# version is via 'python -m ensurepip --upgrade' (which should of course be 'python3 -m ensurepip --upgrade' on systems
# that have both Python 2 and Python 3).  However, on Debian/Ubuntu, this will give an error "No module named ensurepip"
# because ensurepip is deliberately disabled to push you towards using 'sudo apt update' +
# 'sudo apt install python3-pip'.
if (platform.system() != 'Linux'):
   # https://docs.python.org/3/library/sys.html#sys.executable says sys.executable is '"the absolute path of the
   # executable binary for the Python interpreter, on systems where this makes sense".
   log.info(
      'Attempting to ensure latest version of Pip is installed via  ' + sys.executable + ' -m ensurepip --upgrade'
   )
   subprocess.run([sys.executable, '-m', 'ensurepip', '--upgrade'])
else:
   # We don't want to run a sudo command every time the script is invoked, so check whether it's necessary
   exe_pip = shutil.which('pip3')
   if (exe_pip is None or exe_pip == ''):
      log.info('Attempting to install Pip')
      subprocess.run(['sudo', 'apt', 'update'])
      subprocess.run(['sudo', 'apt', 'install', 'python3-pip'])


# If Pip still isn't installed we need to bail here.
exe_pip = shutil.which('pip3')
if (exe_pip is None or exe_pip == ''):
   pathEnvVar = ''
   if ('PATH' in os.environ):
      pathEnvVar = os.environ['PATH']
   log.critical(
      'Cannot find pip (PATH=' + pathEnvVar + ') - please see https://pip.pypa.io/en/stable/installation/ for how to ' +
      'install'
   )
   exit(1)
#
# We use the packaging module (see https://pypi.org/project/packaging/) for handling version numbers (as described at
# https://packaging.pypa.io/en/stable/version.html).
#
# On MacOS at least, we also need to install setuptools to be able to access packaging.version.
#
subprocess.run([exe_pip, 'install', 'packaging'])
subprocess.run([exe_pip, 'install', 'setuptools'])
import packaging.version

# The requests library (see https://pypi.org/project/requests/) is used for downloading files in a more Pythonic way
# than invoking wget through the shell.
subprocess.run([exe_pip, 'install', 'requests'])
import requests

#
# Once all platforms we're running on have Python version 3.11 or above, we will be able to use the built-in tomllib
# library (see https://docs.python.org/3/library/tomllib.html) for parsing TOML.  Until then, it's easier to import the
# tomlkit library (see https://pypi.org/project/tomlkit/) which actually has rather more functionality than we need
#
subprocess.run([exe_pip, 'install', 'tomlkit'])
import tomlkit

#-----------------------------------------------------------------------------------------------------------------------
# Parse command line arguments
#-----------------------------------------------------------------------------------------------------------------------
# We do this (nearly) first as we want the program to exit straight away if incorrect arguments are specified
# Choosing which action to call is done a the end of the script, after all functions are defined
#
# Using Python argparse saves us writing a lot of boilerplate, although the help text it generates on the command line
# is perhaps a bit more than we want (eg having to separate 'bt --help' and 'bt setup --help' is overkill for us).
# There are ways around this -- eg see
# https://stackoverflow.com/questions/20094215/argparse-subparser-monolithic-help-output -- but they are probably more
# complexity than is merited here.
#
parser = argparse.ArgumentParser(
   prog = 'bt',
   description = capitalisedProjectName + ' build tool.  A utility to help with installing dependencies, Git ' +
                 'setup, Meson build configuration and packaging.',
   epilog = 'See ' + projectUrl + ' for info and latest releases'
)

# Log level
group = parser.add_mutually_exclusive_group()
group.add_argument('-v', '--verbose', action = 'store_true', help = 'Enable debug logging of this script')
group.add_argument('-q', '--quiet',   action = 'store_true', help = 'Suppress info logging of this script')

# Per https://docs.python.org/3/library/argparse.html#sub-commands, you use sub-parsers for sub-commands.
subparsers = parser.add_subparsers(
   dest = 'subCommand',
   required = True,
   title = 'action',
   description = "Exactly one of the following actions must be specified.  (For actions marked ✴, specify -h or "
                 "--help AFTER the action for info about options -- eg '%(prog)s setup --help'.)"
)

# Parser for 'setup'
parser_setup = subparsers.add_parser('setup', help = '✴ Set up meson build directory (mbuild) and git options')
subparsers_setup = parser_setup.add_subparsers(dest = 'setupOption', required = False)
parser_setup_all = subparsers_setup.add_parser(
   'all',
   help = 'Specifying this will also automatically install libraries and frameworks we depend on'
)

# Parser for 'package'
parser_package = subparsers.add_parser('package', help='Build a distributable installer')

#
# Process the arguments for use below
#
# This try/expect ensures that help is printed if the script is invoked without arguments.  It's not perfect as you get
# the usage line twice (because parser.parse_args() outputs it to stderr before throwing SystemExit) but it's good
# enough for now at least.
#
try:
   args = parser.parse_args()
except SystemExit as se:
   if (se.code != None and se.code != 0):
      parser.print_help()
   sys.exit(0)

#
# The one thing we do set straight away is log level
# Possible levels are 'CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG', 'NOTSET'.  We choose 'INFO' for default, 'DEBUG'
# for verbose and 'WARNING' for quiet.  You wouldn't want to suppress warnings, would you? :-)
#
if (args.verbose):
   log.setLevel(logging.DEBUG)
elif (args.quiet):
   log.setLevel(logging.WARNING)

log.debug('Parsed command line arguments as ' + str(args))

#-----------------------------------------------------------------------------------------------------------------------
# Note the working directory from which we were invoked -- though it shouldn't matter as we try to be independent of
# this
#-----------------------------------------------------------------------------------------------------------------------
log.debug('Working directory when invoked: ' + pathlib.Path.cwd().as_posix())

#-----------------------------------------------------------------------------------------------------------------------
# Directories
#-----------------------------------------------------------------------------------------------------------------------
dir_base          = pathlib.Path(__file__).parent.resolve()
dir_gitInfo       = dir_base.joinpath('.git')
dir_build         = dir_base.joinpath('mbuild')
dir_gitSubmodules = dir_base.joinpath('third-party')
dir_packaging          = dir_build.joinpath('packaging')             # Top-level packaging directory
dir_packaging_platform = dir_packaging.joinpath(platform.system().lower())   # Platform-specific packaging directory

# See comment in doPackage() for explanation of qtIfw directory tree
dir_qtIfw           = dir_build.joinpath('qtIfw')
dir_qtIfw_config    = dir_qtIfw.joinpath('config')
dir_qtIfw_packages  = dir_qtIfw.joinpath('packages')
dir_qtIfw_component = dir_qtIfw_packages.joinpath('com.' + projectName + '.root')
dir_qtIfw_data      = dir_qtIfw_component.joinpath('data')
dir_qtIfw_meta      = dir_qtIfw_component.joinpath('meta')
dirList_qtIfw = [
   dir_qtIfw          ,
   dir_qtIfw_config   ,
   dir_qtIfw_packages ,
   dir_qtIfw_component,
   dir_qtIfw_data     ,
   dir_qtIfw_meta     ,
]

#-----------------------------------------------------------------------------------------------------------------------
# Helper function for checking result of running external commands
#
# Given a CompletedProcess object returned from subprocess.run(), this checks the return code and, if it is non-zero
# stops this script with an error message and the same return code.  Otherwise the CompletedProcess object is returned
# to the caller (to make it easier to chain things together).
#-----------------------------------------------------------------------------------------------------------------------
def abortOnRunFail(runResult: subprocess.CompletedProcess):
   if (runResult.returncode != 0):
      # According to https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess,
      # CompletedProcess.args (the arguments used to launch the process) "may be a list or a string", but its not clear
      # when it would be one or the other.
      if (isinstance(runResult.args, str)):
         log.critical('Error running ' + runResult.args)
      else:
         commandName = os.path.basename(runResult.args[0])
         log.critical('Error running ' + commandName + ' (' + ' '.join(str(ii) for ii in runResult.args) + ')')

      exit(runResult.returncode)

   return runResult

#-----------------------------------------------------------------------------------------------------------------------
# Helper function for copying one or more files to a directory that might not yet exist
#-----------------------------------------------------------------------------------------------------------------------
def copyFilesToDir(files, directory):
   os.makedirs(directory, exist_ok=True)
   for currentFile in files:
      shutil.copy2(currentFile, directory)
   return;

#-----------------------------------------------------------------------------------------------------------------------
# Helper function for counting files in a directory tree
#-----------------------------------------------------------------------------------------------------------------------
def numFilesInTree(path):
   numFiles = 0
   for root, dirs, files in os.walk(path):
      numFiles += len(files)
   return numFiles

#-----------------------------------------------------------------------------------------------------------------------
# Helper function for downloading a file
#-----------------------------------------------------------------------------------------------------------------------
def downloadFile(url):
   filename = url.split('/')[-1]
   log.info('Downloading ' + url + ' to ' + filename + ' in directory ' + pathlib.Path.cwd().as_posix())
   response = requests.get(url)
   if (response.status_code != 200):
      log.critical('Error code ' + response.status_code + ' while downloading ' + url)
      exit(1)
   with open(filename, 'wb') as fd:
      for chunk in response.iter_content(chunk_size = 128):
         fd.write(chunk)
   return

#-----------------------------------------------------------------------------------------------------------------------
# Set global variables exe_git and exe_meson with the locations of the git and meson executables
#
# We want to give helpful error messages if Meson or Git is not installed.  For other missing dependencies we can rely
# on Meson itself to give explanatory error messages.
#-----------------------------------------------------------------------------------------------------------------------
def findMesonAndGit():
   # Advice at https://docs.python.org/3/library/subprocess.html is "For maximum reliability, use a fully qualified path
   # for the executable. To search for an unqualified name on PATH, use shutil.which()"

   # Check Meson is installed.  (See installDependencies() below for what we do to attempt to install it from this
   # script.)
   global exe_meson
   exe_meson = shutil.which("meson")
   if (exe_meson is None or exe_meson == ""):
      log.critical('Cannot find meson - please see https://mesonbuild.com/Getting-meson.html for how to install')
      exit(1)

   # Check Git is installed if its magic directory is present
   global exe_git
   exe_git   = shutil.which("git")
   if (dir_gitInfo.is_dir()):
      log.debug('Found git information directory:' + dir_gitInfo.as_posix())
      if (exe_git is None or exe_git == ""):
         log.critical('Cannot find git - please see https://git-scm.com/downloads for how to install')
         exit(1)

   return

#-----------------------------------------------------------------------------------------------------------------------
# Function to install dependencies -- called if the user runs 'bt setup all'
#-----------------------------------------------------------------------------------------------------------------------
def installDependencies():
   log.info('Checking which dependencies need to be installed')
   #
   # I looked at using ConanCenter (https://conan.io/center/) as a source of libraries, so that we could automate
   # installing dependencies, but it does not have all the ones we need.  Eg it has Boost, Qt, Xerces-C and Valijson,
   # but not Xalan-C.  (Someone else has already requested Xalan-C, see
   # https://github.com/conan-io/conan-center-index/issues/5546, but that request has been open a long time, so its
   # fulfilment doesn't seem imminent.)  It also doesn't yet integrate quite as well with meson as we might like (eg
   # as at 2023-01-15, https://docs.conan.io/en/latest/reference/conanfile/tools/meson.html is listed as "experimental
   # and subject to breaking changes".
   #
   # Another option is vcpkg (https://vcpkg.io/en/index.html), which does have both Xerces-C and Xalan-C, along with
   # Boost, Qt and Valijson.  There is an example here https://github.com/Neumann-A/meson-vcpkg of how to use vcpkg from
   # Meson.  However, it's pretty slow to get started with because it builds from source everything it installs
   # (including tools it depends on such as CMake) -- even if they are already installed on your system from another
   # source.  This is laudably correct but I'm too impatient to do things that way.
   #
   # Will probably take another look at Conan in future, subject to working out how to have it use already-installed
   # versions of libraries/frameworks if they are present.  The recommended way to install Conan is via a Python
   # package, which makes that part easy.  However, there is a fair bit of other ramp-up to do, and some breaking
   # changes between "current" Conan 1.X and "soon-to-be-released" Conan 2.0.  So, will leave it for now and stick
   # mostly to native installs for each of the 3 platforms (Linux, Windows, Mac).
   #
   match platform.system():

      #-----------------------------------------------------------------------------------------------------------------
      #---------------------------------------------- Linux Dependencies -----------------------------------------------
      #-----------------------------------------------------------------------------------------------------------------
      case 'Linux':
         #
         # NOTE: For the moment at least, we are assuming you are on Ubuntu or another Debian-based Linux.  For other
         # flavours of the OS you need to install libraries and frameworks manually.
         #

         #
         # We need a recent version of Boost, ie Boost 1.79 or newer, to use Boost.JSON.  For Windows and Mac this is
         # fine if you are installing from MSYS2 (https://packages.msys2.org/package/mingw-w64-x86_64-boost) or
         # Homebrew (https://formulae.brew.sh/formula/boost) respectively.  Unfortunately, as of late-2022, many
         # Linux distros provide only older versions of Boost.  (Eg, on Ubuntu, you can see this by running
         # 'apt-cache policy libboost-dev'.)
         #
         # First, check whether Boost is installed and if so, what version
         #
         # We'll look in the following places:
         #    /usr/include/boost/version.hpp        <-- Distro-installed Boost
         #    /usr/local/include/boost/version.hpp  <-- Manually-installed Boost
         #    ${BOOST_ROOT}/boost/version.hpp       <-- If the BOOST_ROOT environment variable is set it gives an
         #                                              alternative place to look
         #
         # Although things should compile with 1.79.0, if we're going to all the bother of installing Boost, we'll
         # install a more recent one
         minBoostVersion = packaging.version.parse('1.79.0')
         boostVersionToInstall = packaging.version.parse('1.80.0') # NB: This _must_ have the patch version
         maxBoostVersionFound = packaging.version.parse('0')
         possibleBoostVersionHeaders = [pathlib.Path('/usr/include/boost/version.hpp'),
                                          pathlib.Path('/usr/local/include/boost/version.hpp')]
         if ('BOOST_ROOT' in os.environ):
            possibleBoostVersionHeaders.append(pathlib.Path(os.environ['BOOST_ROOT']).joinpath('boost/version.hpp'))
         for boostVersionHeader in possibleBoostVersionHeaders:
            if (boostVersionHeader.is_file()):
               runResult = abortOnRunFail(
                  subprocess.run(
                     ['grep', '#define BOOST_LIB_VERSION ', boostVersionHeader.as_posix()],
                     encoding = "utf-8",
                     capture_output = True
                  )
               )
               log.debug('In ' + boostVersionHeader.as_posix() + ' found ' + str(runResult.stdout))
               versionFoundRaw = re.sub(
                  r'^.*BOOST_LIB_VERSION "([0-9_]*)".*$', r'\1', str(runResult.stdout).replace('\n', '')
               ).replace('_', '.')
               versionFound = packaging.version.parse(versionFoundRaw)
               if (versionFound > maxBoostVersionFound):
                  maxBoostVersionFound = versionFound
               log.debug('Parsed as ' + str(versionFound) + '.  (Highest found = ' + str(maxBoostVersionFound) + ')')

         #
         # The Boost version.hpp configuration header file gives two constants for defining the version of Boost
         # installed:
         #
         # BOOST_VERSION is a pure numeric value:
         #    BOOST_VERSION % 100 is the patch level
         #    BOOST_VERSION / 100 % 1000 is the minor version
         #    BOOST_VERSION / 100000 is the major version
         # So, eg, for Boost 1.79.0 (= 1.079.00), BOOST_VERSION = 107900
         #
         # BOOST_LIB_VERSION is a string value with underscores instead of dots (and without the patch level if that's
         # 0).  So, eg for Boost 1.79.0, BOOST_LIB_VERSION = "1_79" (and for 1.23.45 it would be "1_23_45")
         #
         # We use BOOST_LIB_VERSION as it's easy to convert it to a version number that Python can understand
         #
         log.debug(
            'Max version of Boost found: ' + str(maxBoostVersionFound) + '.  Need >= ' + str(minBoostVersion) +
            ', otherwise will try to install ' + str(boostVersionToInstall)
         )
         if (maxBoostVersionFound < minBoostVersion):
            log.info(
               'Installing Boost ' + str(boostVersionToInstall) + ' as newest version found was ' +
               str(maxBoostVersionFound)
            )
            #
            # To manually install the latest version of Boost from source, first we uninstall any old version
            # installed via the distro (eg, on Ubuntu, this means 'sudo apt remove libboost-all-dev'), then we follow
            # the instructions at https://www.boost.org/more/getting_started/index.html.
            #
            # It's best to leave the default install location: headers in the 'boost' subdirectory of
            # /usr/local/include and libraries in /usr/local/lib.
            #
            # (It might initially _seem_ a good idea to put things in the same place as the distro packages, ie
            # running './bootstrap.sh --prefix=/usr' to put headers in /usr/include and libraries in /usr/lib.
            # However, this will mean that Meson cannot find the manually-installed Boost, even though it can find
            # distro-installed Boost in this location.)  So, eg, for Boost 1.80 on Linux, this means the following
            # in the shell:
            #
            #    cd ~
            #    mkdir ~/boost-tmp
            #    cd ~/boost-tmp
            #    wget https://boostorg.jfrog.io/artifactory/main/release/1.80.0/source/boost_1_80_0.tar.bz2
            #    tar --bzip2 -xf boost_1_80_0.tar.bz2
            #    cd boost_1_80_0
            #    ./bootstrap.sh
            #    sudo ./b2 install
            #    cd ~
            #    sudo rm -rf ~/boost-tmp
            #
            # We can handle the temporary directory stuff more elegantly (ie RAII style) in Python however
            #
            with tempfile.TemporaryDirectory(ignore_cleanup_errors = True) as tmpDirName:
               previousWorkingDirectory = pathlib.Path.cwd().as_posix()
               os.chdir(tmpDirName)
               log.debug('Working directory now ' + pathlib.Path.cwd().as_posix())
               boostUnderscoreName = 'boost_' + str(boostVersionToInstall).replace('.', '_')
               downloadFile(
                  'https://boostorg.jfrog.io/artifactory/main/release/' + str(boostVersionToInstall) + '/source/' +
                  boostUnderscoreName + '.tar.bz2'
               )
               log.debug('Boost download completed')
               shutil.unpack_archive(boostUnderscoreName + '.tar.bz2')
               log.debug('Boost archive extracted')
               os.chdir(boostUnderscoreName)
               log.debug('Working directory now ' + pathlib.Path.cwd().as_posix())
               abortOnRunFail(subprocess.run(['./bootstrap.sh']))
               log.debug('Boost bootstrap finished')
               abortOnRunFail(subprocess.run(['sudo', './b2', 'install']))
               log.debug('Boost install finished')
               os.chdir(previousWorkingDirectory)
               log.debug('Working directory now ' + pathlib.Path.cwd().as_posix() + '.  Removing ' + tmpDirName)
               #
               # The only issue with the RAII approach to removing the temporary directory is that some of the files
               # inside it will be owned by root, so there will be a permissions error when Python attempts to delete
               # the directory tree.  Fixing the permissions beforehand is a slightly clunky way around this.
               #
               abortOnRunFail(
                  subprocess.run(
                     ['sudo', 'chmod', '--recursive', 'a+rw', tmpDirName]
                  )
               )

         # Almost everything else we can rely on the distro packages
         # Note that we need CMake even for the Meson build because meson uses CMake as one of its library-finding tools
         log.info('Ensuring other libraries and frameworks are installed')
         abortOnRunFail(subprocess.run(['sudo', 'apt-get', 'update']))
         abortOnRunFail(
            subprocess.run(
               ['sudo', 'apt', 'install', '-y', 'cmake',
                                                'debhelper',
                                                'git',
                                                'libqt5multimedia5-plugins',
                                                'libqt5sql5-psql',
                                                'libqt5sql5-sqlite',
                                                'libqt5svg5-dev',
                                                'libxalan-c-dev',
                                                'libxerces-c-dev',
                                                'lintian',
                                                'meson',
                                                'ninja-build',
                                                'python3',
                                                'qtbase5-dev',
                                                'qtmultimedia5-dev',
                                                'qttools5-dev',
                                                'qttools5-dev-tools',
                                                'rpm',
                                                'rpmlint']
            )
         )

         #
         # Ubuntu 20.04 packages only have Meson 0.53.2, and we need 0.60.0 or later.  In this case it means we have to
         # install Meson via pip, which is not ideal on Linux.
         #
         # Specifically, as explained at https://mesonbuild.com/Getting-meson.html#installing-meson-with-pip, although
         # using the pip3 install gets a newer version, we have to do the pip install as root (which is normally not
         # recommended).  If we don't do this, then running `meson install` (or even `sudo meson install`) will barf on
         # Linux (because we need to be able to install files into system directories).
         #
         # So, where a sufficiently recent version of Meson is available in the distro packages (eg
         # `sudo apt install meson` on Ubuntu etc) it is much better to install this.   Installing via pip is a last
         # resort.
         #
         # The distro ID we get from 'lsb_release -is' will be 'Ubuntu' for all the variants of Ubuntu (eg including
         # Kubuntu).  Not sure what happens on derivatives such as Linux Mint though.
         #
         distroName = str(
            abortOnRunFail(subprocess.run(['lsb_release', '-is'], encoding = "utf-8", capture_output = True)).stdout
         ).replace('\n', '')
         log.debug('Linux distro: ' + distroName)
         if ('Ubuntu' == distroName):
            ubuntuRelease = str(
               abortOnRunFail(subprocess.run(['lsb_release', '-rs'], encoding = "utf-8", capture_output = True)).stdout
            ).replace('\n', '')
            log.debug('Ubuntu release: ' + ubuntuRelease)
            if (Decimal(ubuntuRelease) < Decimal('22.04')):
               log.info('Installing newer version of Meson the hard way')
               abortOnRunFail(subprocess.run(['sudo', 'apt', 'remove', '-y', 'meson']))
               abortOnRunFail(subprocess.run(['sudo', 'pip3', 'install', 'meson']))

      #-----------------------------------------------------------------------------------------------------------------
      #--------------------------------------------- Windows Dependencies ----------------------------------------------
      #-----------------------------------------------------------------------------------------------------------------
      case 'Windows':
         log.debug('Windows')
         #
         # First thing is to detect whether we're in the MSYS2 environment, and, if so, whether we're in the right
         # version of it.
         #
         # We take the existence of an executable `uname` in the path as a pretty good indicator that we're in MSYS2
         # or similar environment).  Then the result of running that should tell us if we're in the 32-bit version of
         # MSYS2.  (See comment below on why we don't yet support the 64-bit version, though I'm sure we'll fix this one
         # day.)
         #
         exe_uname = shutil.which('uname')
         if (exe_uname is None or exe_uname == ''):
            log.critical('Cannot find uname.  This script needs to be run under MSYS2 - see https://www.msys2.org/')
            exit(1)
         # We could just run uname without the -a option, but the latter gives some useful diagnostics to log
         unameResult = str(
            abortOnRunFail(subprocess.run([exe_uname, '-a'], encoding = "utf-8", capture_output = True)).stdout
         )
         log.debug('Running uname -a gives ' + unameResult)
         # Output from `uname -a` will be of the form
         #    MINGW64_NT-10.0-19044 Matt-Virt-Win 3.4.3.x86_64 2023-01-11 20:20 UTC x86_64 Msys
         # We just need the bit before the first underscore, eg
         #    MINGW64
         terminalVersion = unameResult.split(sep='_', maxsplit=1)[0]
         if (terminalVersion != 'MINGW32'):
            # One day we'll try to get the 64-bit build working on Windows.  I think it's just the packaging step that's
            # the problem.  For now, it's easier to insist on 32-bit at set-up.  (Obviously 32-bit apps run just fine on
            # 64-bit Windows.  I don't think there would be any noticeable difference to the end user in having a 64-bit
            # version of the app.)
            log.critical('Running in ' + terminalVersion + ' but need to run in MINGW32 (ie 32-bit build environment)')
            exit(1)

         log.info('Ensuring required libraries and frameworks are installed')
         #
         # Before we install packages, we want to make sure the MSYS2 installation itself is up-to-date, otherwise you
         # can hit problems
         #
         #   pacman -S -y should download a fresh copy of the master package database
         #   pacman -S -u should upgrades all currently-installed packages that are out-of-date
         #
         abortOnRunFail(subprocess.run(['pacman', '-S', '-y', '--noconfirm']))
         abortOnRunFail(subprocess.run(['pacman', '-S', '-u', '--noconfirm']))

         #
         # We'd normally want to go with the 64-bit versions of things (x86_64) but AIUI it's a bit hard to handle this
         # in the NSIS installer, so we the 32-bit versions (i686).
         #
         # We _could_ just invoke pacman once with the list of everything we want to install.  However, this can make
         # debugging a bit harder when there is a pacman problem, because it doesn't always give the most explanatory
         # error messages.  So we loop round and install one thing at a time.
         #
         arch = 'i686'
         installList = ['base-devel',
                        'cmake',
                        'doxygen',
                        'gcc',
                        'git',
                        'mingw-w64-' + arch + '-boost',
                        'mingw-w64-' + arch + '-cmake',
                        'mingw-w64-' + arch + '-libbacktrace',
                        'mingw-w64-' + arch + '-meson',
                        'mingw-w64-' + arch + '-nsis',
                        'mingw-w64-' + arch + '-qt5',
                        'mingw-w64-' + arch + '-toolchain',
                        'mingw-w64-' + arch + '-xalan-c',
                        'mingw-w64-' + arch + '-xerces-c']
         for packageToInstall in installList:
            log.debug('Installing ' + packageToInstall)
            abortOnRunFail(
               subprocess.run(
                  ['pacman', '-S', '--needed', '--noconfirm', packageToInstall]
               )
            )

         #
         # Download NSIS plugins
         #
         # In theory we can use RAII here, eg:
         #
         #   with tempfile.TemporaryDirectory(ignore_cleanup_errors = True) as tmpDirName:
         #      previousWorkingDirectory = pathlib.Path.cwd().as_posix()
         #      os.chdir(tmpDirName)
         #      ...
         #      os.chdir(previousWorkingDirectory)
         #
         # However, in practice, this gets messy when there is an error (eg download fails) because Windows doesn't like
         # deleting files or directories that are in use.  So, in the event of the script needing to terminate early,
         # you get loads of errors, up to and including "maximum recursion depth exceeded" which rather mask whatever
         # the original problem was.
         #
         tmpDirName = tempfile.mkdtemp()
         previousWorkingDirectory = pathlib.Path.cwd().as_posix()
         os.chdir(tmpDirName)
         downloadFile('https://nsis.sourceforge.io/mediawiki/images/a/af/Locate.zip')
         shutil.unpack_archive('Locate.zip', 'Locate')
         downloadFile('https://nsis.sourceforge.io/mediawiki/images/7/76/Nsislog.zip')
         shutil.unpack_archive('Nsislog.zip', 'Nsislog')
         copyFilesToDir(['Locate/Include/Locate.nsh'], '/mingw32/share/nsis/Include/')
         copyFilesToDir(['Locate/Plugin/locate.dll',
                         'Nsislog/plugin/nsislog.dll'],'/mingw32/share/nsis/Plugins/ansi/')
         os.chdir(previousWorkingDirectory)
         shutil.rmtree(tmpDirName, ignore_errors=False)

      #-----------------------------------------------------------------------------------------------------------------
      #---------------------------------------------- Mac OS Dependencies ----------------------------------------------
      #-----------------------------------------------------------------------------------------------------------------
      case 'Darwin':
         log.debug('Mac')
         #
         # We could make this list shorter if we wanted as, eg, installing Xalan-C will cause Xerces-C to be installed
         # too (as the former depends on the latter).  However, I think it's clearer to explicitly list all the direct
         # dependencies (eg we do make calls directly into Xerces).
         #
         # For the moment, we install Qt 5 (= 5.15.7), as there are code changes required to use Qt 6
         #
         # .:TBD:. Installing Boost here doesn't seem to give us libboost_stacktrace_backtrace
         #         Also, trying to use the "--cc=clang" option to install boost gives an error ("Error: boost: no bottle
         #         available!")  For the moment, we're just using Boost header files on Mac though, so this should be
         #         OK.
         #
         installList = ['boost',
                        'cmake',
                        'doxygen',
                        'gcc',
                        'git',
                        'llvm',
                        'meson',
                        'ninja',
                        'qt@5',
                        'xalan-c',
                        'xerces-c']
         for packageToInstall in installList:
            log.debug('Installing ' + packageToInstall)
            abortOnRunFail(subprocess.run(['brew', 'install', packageToInstall]))
         #
         # By default, even once Qt5 is installed, Meson will not find it
         #
         # See https://stackoverflow.com/questions/29431882/get-qt5-up-and-running-on-a-new-mac for suggestion to do
         # the following to "symlink the various Qt5 binaries and libraries into your /usr/local/bin and /usr/local/lib
         # directories".
         #
         # Additionally, per lengthy discussion at https://github.com/Homebrew/legacy-homebrew/issues/29938, it seems
         # we might also need either:
         #    ln -s /usr/local/Cellar/qt5/5.15.7/mkspecs /usr/local/mkspecs
         #    ln -s /usr/local/Cellar/qt5/5.15.7/plugins /usr/local/plugins
         # or:
         #    export PATH=/usr/local/opt/qt5/bin:$PATH
         # The former gives permission errors, so we do the latter in mac.yml
         #
         abortOnRunFail(subprocess.run(['brew', 'link', '--force', 'qt5']))

      case _:
         log.critical('Unrecognised platform: ' + platform.system())
         exit(1)

   #--------------------------------------------------------------------------------------------------------------------
   #------------------------------------------- Cross-platform Dependencies --------------------------------------------
   #--------------------------------------------------------------------------------------------------------------------
   #
   # We use libbacktrace from https://github.com/ianlancetaylor/libbacktrace.  It's not available as a Debian package
   # and not any more included with GCC by default.  It's not a large library so, unless and until we start using Conan,
   # the easiest approach seems to be to bring it in as a Git submodule and compile from source.
   #
   # (Adding submodules is done via Git itself.  Eg:
   #    cd ../third-party
   #    git submodule add https://github.com/ianlancetaylor/libbacktrace
   # But this only needs to be done once, by one person, and committed to our repository, where the connection is
   # stored in the .gitmodules file.)
   #
   log.info('Checking libbacktrace is built')
   previousWorkingDirectory = pathlib.Path.cwd().as_posix()
   backtraceDir = dir_gitSubmodules.joinpath('libbacktrace')
   os.chdir(backtraceDir)
   log.debug('Run configure and make in ' + backtraceDir.as_posix())
   # Libbacktrace uses autoconf/automake so it's relatively simple to build
   # Note that, although on Linux you can just invoke `./configure`, this doesn't work in the MSYS2 environment, so,
   # knowing that 'configure' is a shell script, we invoke it as such.
   abortOnRunFail(subprocess.run(['bash', './configure']))
   abortOnRunFail(subprocess.run(['make']))
   os.chdir(previousWorkingDirectory)

   log.info('*** Finished checking / installing dependencies ***')
   return

#-----------------------------------------------------------------------------------------------------------------------
# ./bt setup
#-----------------------------------------------------------------------------------------------------------------------
def doSetup(setupOption):
   if (setupOption == 'all'):
      installDependencies()

   findMesonAndGit()

   # If this is a git checkout then let's set up git with the project standards
   if (dir_gitInfo.is_dir()):
      log.info('Setting up ' + capitalisedProjectName + ' git preferences')
      # Enforce indentation with spaces, not tabs.
      abortOnRunFail(
         subprocess.run(
            [exe_git,
               "config",
               "--file", dir_gitInfo.joinpath('config').as_posix(),
               "core.whitespace",
               "tabwidth=3,tab-in-indent"],
            capture_output=False
         )
      )

      # Enable the standard pre-commit hook that warns you about whitespace errors
      shutil.copy2(dir_gitInfo.joinpath('hooks/pre-commit.sample'),
                     dir_gitInfo.joinpath('hooks/pre-commit'))

      # When a git repository is cloned, the submodules don't get cloned until you specifically ask for it via the
      # --recurse-submodules flag.
      if (not dir_gitSubmodules.is_dir() or numFilesInTree(dir_gitSubmodules) == 0):
         log.info('Pulling in submodules in ' + dir_gitSubmodules.as_posix())
         os.makedirs(dir_gitSubmodules, exist_ok=True)
         abortOnRunFail(subprocess.run([exe_git, "submodule", "init"], capture_output=False))
         abortOnRunFail(subprocess.run([exe_git, "submodule", "update"], capture_output=False))

   # Check whether Meson build directory is already set up.  (Although nothing bad happens, if you run setup twice,
   # it complains and tells you to run configure.)
   # Best clue that set-up has been run (rather than, say, user just created empty mbuild directory by hand) is the
   # presence of meson-info/meson-info.json (which is created by setup for IDE integration -- see
   # https://mesonbuild.com/IDE-integration.html#ide-integration)
   runMesonSetup = True
   warnAboutCurrentDirectory = False
   if (dir_build.joinpath('meson-info/meson-info.json').is_file()):
      log.info('Meson build directory ' + dir_build.as_posix() + ' appears to be already set up')
      #
      # You usually only need to reset things after you've done certain edits to defaults etc in meson.build.  There
      # are a whole bunch of things you can control with the 'meson configure' command, but it's simplest in some ways
      # just to reset the build directory and rely on meson setup picking up defaults from meson.build.
      #
      # Note that we don't have to worry about this prompt appearing in a GitHub action, because we are always creating
      # the mbuild directory for the first time when this script is run in such actions -- ie we should never reach this
      # part of the code.
      #
      response = ""
      while (response != 'y' and response != 'n'):
         response = input('Do you want to completely reset the build directory? [y or n] ').lower()
      if (response == 'n'):
         runMesonSetup = False
      else:
         # It's very possible that the user's current working directory is mbuild.  If so, we need to warn them and move
         # up a directory (as 'meson setup' gets upset if current working directory does not exist).
         log.info('Removing existing Meson build directory ' + dir_build.as_posix())
         if (pathlib.Path.cwd().as_posix() == dir_build.as_posix()):
            # We write a warning out here for completeness, but we really need to show it further down as it will have
            # scrolled off the top of the terminal with all the output from 'meson setup'
            log.warning('You are currently in the directory we are about to delete.  ' +
                        'You will need to change directory!')
            warnAboutCurrentDirectory = True
            os.chdir(dir_base)
         shutil.rmtree(dir_build)

   if (runMesonSetup):
      log.info('Setting up ' + dir_build.as_posix() + ' meson build directory')
      # See https://mesonbuild.com/Commands.html#setup for all the optional parameters to meson setup
      # Note that meson setup will create the build directory (along with various subdirectories)
      abortOnRunFail(subprocess.run([exe_meson, "setup", dir_build.as_posix(), dir_base.as_posix()],
                                    capture_output=False))

      log.info('Finished setting up Meson build.  Note that the warnings above about path separator and optimization ' +
               'level are expected!')

   if (warnAboutCurrentDirectory):
      print("❗❗❗ Your current directory has been deleted!  You need to run 'cd ../mbuild' ❗❗❗")
   log.debug('Setup done')
   print()
   print('You can now build, test, install and run ' + capitalisedProjectName + ' with the following commands:')
   print('   cd ' + os.path.relpath(dir_build))
   print('   meson compile')
   print('   meson test')
   if (platform.system() == 'Linux'):
      print('   sudo meson install')
   else:
      print('   meson install')
   print('   ' + projectName)


   return

#-----------------------------------------------------------------------------------------------------------------------
# ./bt package
#-----------------------------------------------------------------------------------------------------------------------
def doPackage():
   #
   # Meson does not offer a huge amount of help on creating installable packages.  It has no equivalent to CMake's CPack
   # and there is generally not a lot of info out there about how to do packaging in Meson.  OTOH, although CPack has
   # lots of features it is also very painful to use.  Some of the things you can do are undocumented; some of the
   # things you want to be able to do seem nigh on impossible.  So maybe taking a completely different approach is a
   # good thing.
   #
   # I spent some time looking at and trying to use the Qt-Installer-Framework (QtIFW).  Upsides are:
   #   - In principle we could write one set of install config that would then create install packages for Windows, Mac
   #     and Linux.
   #   - It should already know how to package Qt libraries(!)
   #   - It's the same licence as the rest of Qt.
   #   - We could use it in GitHub actions (courtesy of https://github.com/jurplel/install-qt-action).
   #   - It can handle in-place upgrades (including the check for whether an upgraded version is available), per
   #     https://doc.qt.io/qtinstallerframework/ifw-updates.html.
   # Downsides are:
   #   - Outside of packaging Qt itself, I'm not sure that it's hugely widely used.  It can be hard to find "how tos" or
   #     other assistance.
   #   - It's not a great advert for itself -- eg when I installed it locally on Kubuntu by downloading directly from
   #     https://download.qt.io/official_releases/qt-installer-framework/, it didn't put its own tools in the PATH,
   #     so I had to manually add ~/Qt/QtIFW-4.5.0/bin/ to my PATH.
   #   - It usually necessary to link against a static build of Qt, which is a bit of a pain as you have to download the
   #     source files for Qt and compile it locally -- see eg
   #     https://stackoverflow.com/questions/14932315/how-to-compile-qt-5-under-windows-or-linux-32-or-64-bit-static-or-dynamic-on-v
   #     for the whole process.
   #   - It's a change of installation method for people who have previously downloaded deb packages, RPMs, Mac DMG
   #     files, etc.
   #   - It puts things in different places than 'native' installers.  Eg, on Linux, everything gets installed to
   #     subdirectories of the user's home directory rather than the "usual" system directories).  Amongst other things,
   #     this makes it harder for distros etc that want to ship our software.
   #
   # The alternative approach, which I resisted for a fair while, but have ultimately become persuaded is right, is to
   # do Windows, Mac and Linux packaging separately:
   #   - For Mac, there is some info at https://mesonbuild.com/Creating-OSX-packages.html on creating app bundles
   #   - For Linux, there is some mention in the Meson manual of building deb and rpm packages eg
   #     https://mesonbuild.com/Installing.html#destdir-support, but I think you have to do most of the work yourself.
   #     https://blog.devgenius.io/how-to-build-debian-packages-from-meson-ninja-d1c28b60e709 gives some sketchy
   #     starting info on how to build deb packages.  Maybe we could find the equivalent for creating RPMs.  (There used
   #     to be a Meson module for creating RPMs, but it was discontinued per
   #     https://mesonbuild.com/Release-notes-for-0-62-0.html#removal-of-the-rpm-module because it was broken and badly
   #     designed etc.)  Also look at https://openbuildservice.org/.
   #   - For Windows, we could probably use NSIS (Nullsoft Scriptable Install System -- see
   #     https://nsis.sourceforge.io/) -- or similar to create a Windows installer.
   #
   # Although a lot of packaging is platform-specific, the initial set-up is generic.
   #
   #    1. This script (as invoked directly) creates some packaging sub-directories of the build directory and then
   #       invokes Meson
   #    2. Meson installs all the binaries, data files and so on that we need to ship into the packaging directory tree
   #    3. Meson also exports a bunch of build information into a TOML file that we read in.  This saves us duplicating
   #       too many meseon.build settings in this file.
   #

   findMesonAndGit()

   #
   # The top-level directory structure we create inside the build directory (mbuild) for packaging is:
   #
   #    packaging/
   #    │
   #    ├── windows/ For Windows
   #    │
   #    ├── darwin/  For Mac
   #    │
   #    └── linux/   For Linux
   #
   # NB: If you wanted to change this, you would need to make corresponding changes in meson.build
   #

   # Step 1 : Create a top-level package directory structure
   #          We'll make the relevant top-level directory and ensure it starts out empty
   #          (We don't have to make dir_packaging as it will automatically get created by os.makedirs when we ask it to
   #          create dir_packaging_platform.)
   if (dir_packaging_platform.is_dir()):
      log.info('Removing existing ' + dir_packaging_platform.as_posix() + ' directory tree')
      shutil.rmtree(dir_packaging_platform)
   log.info('Creating directory ' + dir_packaging_platform.as_posix())
   os.makedirs(dir_packaging_platform)

   # We change into the build directory.  This doesn't affect the caller (of this script) because we're a separate
   # sub-process from the (typically) shell that invoked us and we cannot change the parent process's working
   # directory.
   os.chdir(dir_build)
   log.debug('Working directory now ' + pathlib.Path.cwd().as_posix())

   #
   # Running 'meson install' with the --destdir option will put all the installable files (program executable,
   # translation files, data files, etc) in subdirectories of the platform-specific packaging directory.  However, it
   # will not bundle up any shared libraries that we need to ship with the application on Windows and Mac.  We handle
   # this in the platform-specific code below.
   #
   log.info('Running meson install with --destdir option')
   # See https://mesonbuild.com/Commands.html#install for the optional parameters to meson install
   abortOnRunFail(subprocess.run([exe_meson, 'install', '--destdir', dir_packaging_platform.as_posix()],
                                 capture_output=False))

   #
   # At the direction of meson.build, Meson should have generated a config.toml file in the build directory that we can
   # read in to get useful settings exported from the build system.
   #
   global buildConfig
   with open(dir_build.joinpath('config.toml').as_posix()) as buildConfigFile:
      buildConfig = tomlkit.parse(buildConfigFile.read())
   #
   # Note however that there are some things that are (often intentionally) difficult or impossible to import to or
   # export from Meson.  (See
   # https://mesonbuild.com/FAQ.html#why-is-meson-not-just-a-python-module-so-i-could-code-my-build-setup-in-python for
   # why it an explicitly design goal not to have the Meson configuration language be Turing-complete.)
   #
   # We deal with some of these in platform-specific code below
   #

   #
   # If meson install worked, we can now do the actual packaging.
   #

###   #======================================================================================================================================
###   # EVERYTHING BELOW HERE IS OUR FIRST STAB AT THE QT INSTALLER.  CURRENT THINKING IS THAT WE'LL DELETE ALL THIS.
###   #
###   # The directory structure we create inside the build directory (mbuild) for packaging is:
###   #
###   #    qtIfw/             <-- Groups all the Qt-IFW stuff together and keeps it separate from what's in the top-level
###   #    │                      build directory.  The binary installer we generate ends up in this directory.
###   #    │
###   #    ├── config/        <-- Global configuration for the installer lives here.  (If needed, a single installer can
###   #    │                      offer the end user choices about which packages (aka components) to install.  We don't
###   #    │                      need that complexity, so we just have one package.)
###   #    └── packages/
###   #        │
###   #        └── com.<appname>.root/  <-- Each subdirectory of packages is supposed to "act as domain-like identifier"
###   #            │                        for a component or subcomponent of the software.  We use the application name
###   #            │                        (ie brewtarget or brewken) for the "domain-like" bit.  We only have one
###   #            │                        subdirectory as we're not offering the end user a choice about which bits of
###   #            │                        functionality to install (otherwise each component and sub-component would also
###   #            │                        have its own packages subdirectory, with names like
###   #            │                        com.<appname>.root.component_foo.subcomponent_bar).
###   #            │
###   #            ├── data/            <-- Contains everything the installer is going to install, all packaged into
###   #            │                        archive files.  Archive files can be 7z (the default), zip, tar.gz, tar.bz2 or
###   #            │                        tar.xz.  Creation of the archive files can be done automatically by the Qt
###   #            │                        tools (eg binarycreator) or beforehand (eg using the archivegen tool that is
###   #            │                        delivered with the Qt Installer Framework) for more control.
###   #            │
###   #            └── meta/            <-- Files in here are not installed; they specify settings for deployment and the
###   #                                     installation process.  "The directory must contain at least a package
###   #                                     information file and all files that you refer to in the package information
###   #                                     file, such as scripts, user interface files, and translations.
###   #                                     TODO: think about localising the installer
###   #
###   # The six steps for creating a QtIFW installer are listed at
###   # https://doc.qt.io/qtinstallerframework/ifw-creating-installers.html.  We actually do them in a different order than
###   # listed because we don't want to duplicate things that meson can do automatically.  (Nor do we want to jump through
###   # hoops trying to bend meson to do things it is not designed for.)
###   #
###
###   # Step 1 : Create a package directory for the installable components
###   #          We'll make all the directories mentioned above and ensure they start out empty
###   if (dir_qtIfw.is_dir()):
###      log.info('Removing existing ' + dir_qtIfw.as_posix() + ' directory tree')
###      shutil.rmtree(dir_qtIfw)
###   for dirToCreate in dirList_qtIfw:
###      log.info('Creating directory ' + dirToCreate.as_posix())
###      os.makedirs(dirToCreate)
###
###   # We change into the build directory.  This doesn't affect the caller (of this script) because we're a separate
###   # sub-process from the (typically) shell that invoked us and we cannot change the parent process's working
###   # directory.
###   os.chdir(dir_build)
###   log.debug('Working directory now ' + pathlib.Path.cwd().as_posix())
###   #
###   # Running 'meson install' with the --destdir option will put all the installable files (program executable,
###   # translation files, data files, etc) in the packaging directory
###   #
###   # It also generates config.xml and package.xml, but does not put them in the right directory
###   #
###   log.info('Running meson install with --destdir option')
###   # See https://mesonbuild.com/Commands.html#install for the optional parameters to meson install
###   abortOnRunFail(subprocess.run([exe_meson, "install", "--destdir", dir_qtIfw_data.as_posix()],
###                                 capture_output=False))
###
###   #
###   # If meson install worked, we can do the actual packaging via 'meson compile package'.  This will end up invoking
###   # another instance of this script, but with the part_3_of_packaging parameter (and a whole bunch of useful
###   # environment variables set by meson).
###   #
###   # Why is it 'meson compile package' rather than, say, 'meson package'?  It's because meson doesn't really know about
###   # packaging and we're just running it to get build info.  So we have a custom meson target called 'package', and when
###   # we ask meson to "compile" a custom target, we can actually have it run the executable of our choice - in this case
###   # this script.
###   #
###   log.info('Running meson compile part_2_of_packaging')
###   abortOnRunFail(subprocess.run([exe_meson, 'compile', 'part_2_of_packaging'], capture_output=False))
###   #======================================================================================================================================

   match platform.system():

      #-----------------------------------------------------------------------------------------------------------------
      #------------------------------------------------ Linux Packaging ------------------------------------------------
      #-----------------------------------------------------------------------------------------------------------------
      case 'Linux':
         log.debug('Linux Packaging - TODO!')
         #
         # Notes on building debian package -- see
         # https://unix.stackexchange.com/questions/30303/how-to-create-a-deb-file-manually
         #
         # You need to install some extras:
         #    sudo apt-get install debhelper build-essential dh-make
         #
         # Then:
         #    # Create the source tarball
         #    meson dist
         #    # Create the debian/ subtree in the build directory
         #    # I think we only want to do this once, because you end up with a lot of example files that you need to
         #    # edit etc.  Or we could have a look at that brewtarget debian project...
         #    dh_make --copyright gpl3 --email mfsy@yahoo.com --single --packagename brewken_0.1.0-1 --file meson-dist/*.tar.xz --yes
         #
         # To create a deb package, we create the following directory structure (where items marked ✅ are installed by meson
         # install with --destdir option, and items marked ✴ are things we need to generate):
         # TODO Mark things with ❌ that are generated by dh_make and not needed...
         #    [projectName]-[versionNumber]_x86_64/
         #    ├── control          ✴  # Contains info about dependencies, maintainer, etc
         #    ├── control.tar.gz   ✴  # Hopefully just a compressed version of the above
         #    ├── data.tar.gz      ✴  # Compressed archive of the usr tree below
         #    ├── debian-binary    ✴  # A text file containing just "2.0"
         #    ├── md5sums          ✴  # = checksums of all the files in the usr tree below
         #    └── usr
         #        ├── bin
         #        │   └── [projectName] ✅   <-- the executable
         #        └── share
         #            ├── [projectName]
         #            │   ├── applications
         #            │   │   └── [projectName].desktop ✅  <-- [filesToInstall_desktop]
         #            │   ├── DefaultData.xml           ✅  <----- [filesToInstall_data]
         #            │   ├── default_db.sqlite         ✅  <--┘
         #            │   ├── icons
         #            │   │   └── hicolor
         #            │   │       └── scalable
         #            │   │           └── apps
         #            │   │               └── [projectName].svg ✅  <-- [filesToInstall_icons]
         #            │   ├── sounds
         #            │   │   └── [All the filesToInstall_sounds .wav files] ✅
         #            │   └── translations_qm
         #            │       └── [All the .qm files generated by qt.compile_translations] ✅
         #            └── doc
         #                └── [projectName]
         #                    ├── changelog.Debian.gz  ✅
         #                    ├── copyright            ✅
         #                    ├── README.md            ✅
         #                    └── RelaseNotes.markdown ✅
         #


      #-----------------------------------------------------------------------------------------------------------------
      #----------------------------------------------- Windows Packaging -----------------------------------------------
      #-----------------------------------------------------------------------------------------------------------------
      case 'Windows':
         log.debug('Windows Packaging - WIP!')
         #
         # There are three main open-source packaging tools available for Windows:
         #
         #    - NSIS (Nullsoft Scriptable Install System) -- see https://nsis.sourceforge.io/
         #      This is widely used and reputedly simple to learn.  Actually the documentation, although OK overall, is
         #      not brilliant for beginners.  When you are trying to write your first installer script, you will find a
         #      frustrating number of errors, omissions and broken links in the documentation.  If you give up on this
         #      and take an existing working script as a starting point, the reference documentation to explain each
         #      command is not too bad.  Plus there are lots of useful titbits on Stack Overflow etc.
         #         What's less good is that the scripting language is rather primitive.  Once you start looking at
         #      variable scope and how to pass arguments to functions, you'll have a good feel for what it was like to
         #      write mainframe assembly language in the 1970s.
         #         There is one other advantage that NSIS has over Wix and Inno Setup, specifically that it is available
         #      as an MSYS2 package (mingw-w64-x86_64-nsis for 64-bit and mingw-w64-i686-nsis for 32-bit), whereas the
         #      others are not.  This makes it easier to script installations, including for the automated builds on
         #      GitHub.
         #
         #    - WiX -- see https://wixtoolset.org/ and https://github.com/wixtoolset/
         #      This is apparently used by a lot of Microsoft's own products and is supposedly pretty robust.  Looks
         #      like you configure/script it with XML and PowerShell.  Most discussion of it says you really first need
         #      to have a good understanding of Windows Installer (https://en.wikipedia.org/wiki/Windows_Installer) and
         #      its MSI package format.  There is a 260 page book called "The Definitive Guide to Windows Installer"
         #      which either is or isn't beginner-friendly depending on who you ask but, either way is about 250 pages
         #      more than I want to have to know about Windows package installation.  If we decided we _needed_ to
         #      produce MSI installers though, this would be the only choice.
         #
         #    - Inno Setup -- see https://jrsoftware.org/isinfo.php and https://github.com/jrsoftware/issrc
         #      Has been around for ages, but is less widely used than NSIS.  Basic configuration is supposedly simpler
         #      than NSIS, as it's based on an INI file (https://en.wikipedia.org/wiki/INI_file), but you also, by
         #      default, have a bit less control over how the installer works.  If you do need to script something you
         #      have to do it in Pascal, so a trip back to the 1980s rather than the 1970s.
         #
         # For the moment, we're sticking with NSIS, which is the devil we know, aka what we've historically used.
         #

         #
         # As mentioned above, not all information about what Meson does is readily exportable.   In particular, I can
         # find no simple way to get the actual directory that a file was installed to.  Eg, on Windows, in an MSYS2
         # environment, the main executable will be in mbuild/packaging/windows/msys64/mingw32/bin/ or similar.  The
         # beginning (mbuild/packaging/windows) and the end (bin) are parts we specify, but the middle bit
         # (msys64/mingw32) is magicked up by Meson and not explicitly exposed to build script commands.
         #
         # Fortunately, we can just search for a directory called bin inside the platform-specific packaging directory
         # and we'll have the right thing.
         #
         packageBinDirList = glob.glob('./**/bin/', root_dir=dir_packaging_platform.as_posix(), recursive=True)
         if (len(packageBinDirList) == 0):
            log.critical(
               'Cannot find bin subdirectory of ' + dir_packaging_platform.as_posix() + ' packaging directory'
            )
            exit(1)
         if (len(packageBinDirList) > 1):
            log.warning(
               'Found more than one bin subdirectory of ' + dir_packaging_platform.as_posix() + ' packaging directory: ' +
               '; '.join(packageBinDirList) + '.  Assuming first is the one we need'
            )

         packageBinDir = dir_packaging_platform.joinpath(packageBinDirList[0])
         log.debug('Package bin dir: ' + packageBinDir.as_posix())

         #
         # We could do the same search for data and doc directories, but we happen to know that they should just be
         # sibling directories of the bin directory we just found.
         #
         packageDataDir = packageBinDir.parent.joinpath('data')
         packageDocDir  = packageBinDir.parent.joinpath('doc')

         #
         # Now we have to deal with shared libraries.  Windows does not have a built-in package manager and it's not
         # realistic for us to require end users to install and use one.  So, any shared library that we cannot
         # statically link into the application needs to be included in the installer.  This mainly applies to Qt.
         # (Although you can, in principle, statically link against Qt, it requires downloading the entire Qt source
         # code and doing a custom build.)  Fortunately, Qt provides a handy utility called windeployqt that should do
         # most of the work for us.
         #
         # Per https://doc.qt.io/qt-6/windows-deployment.html, the windeployqt executable creates all the necessary
         # folder tree "containing the Qt-related dependencies (libraries, QML imports, plugins, and translations)
         # required to run the application from that folder".
         #
         log.debug('Running windeployqt')
         previousWorkingDirectory = pathlib.Path.cwd().as_posix()
         os.chdir(packageBinDir)
         abortOnRunFail(
            subprocess.run(['windeployqt',
                            '--verbose', '2',        # 2 is the maximum
                            projectName + '.exe'],
                           capture_output=False)
         )
         os.chdir(previousWorkingDirectory)

         # Copy the NSIS installer script to where it belongs
         shutil.copy2(dir_build.joinpath('NsisInstallerScript.nsi'), dir_packaging_platform)

         # We change into the packaging directory and invoke the NSIS Compiler (aka MakeNSIS.exe)
         os.chdir(dir_packaging_platform)
         log.debug('Working directory now ' + pathlib.Path.cwd().as_posix())
         abortOnRunFail(
            # FYI, we don't need it here, but if you run makensis from the MSYS2 command line (Mintty), you need double
            # slashes on the options (//V4 instead of /V4 etc).
            subprocess.run(
               [
                  'MakeNSIS.exe', # 'makensis' would also work on MSYS2
                  '/V4',          # Max verbosity/logging
                  # Variables coming from this script are passed in as command-line defines.  Fortunately there aren't
                  # too many of them.
                  '/DBT_PACKAGING_BIN_DIR="'  + packageBinDir.as_posix()  + '"',
                  '/DBT_PACKAGING_DATA_DIR="' + packageDataDir.as_posix() + '"',
                  '/DBT_PACKAGING_DOC_DIR="'  + packageDocDir.as_posix()  + '"',
                  'NsisInstallerScript.nsi',
               ],
               capture_output=False
            )
         )

      #-----------------------------------------------------------------------------------------------------------------
      #------------------------------------------------- Mac Packaging -------------------------------------------------
      #-----------------------------------------------------------------------------------------------------------------
      case 'Darwin':
         log.debug('Mac Packaging - TODO!')
         #
         # The macdeployqt executable shipped with Qt does for Mac what windeployqt does for Windows -- see
         # https://doc.qt.io/qt-6/macos-deployment.html#the-mac-deployment-tool
         #
         # At first glance, you might thanks that, with a few name changes, we might share all the bt code for
         # macdeployqt and windeployqt.  However, as you will see below, the two programs share _only_ a top-level goal
         # ("automate the process of creating a deployable [folder / application bundle] that contains [the necessary Qt
         # dependencies]" - ie so that the end user does not have to install Qt to run our software).  They have
         # completely different implementations and command line options, so it would be unhelpful to try to treat them
         # identically.
         #

      case _:
         log.critical('Unrecognised platform: ' + platform.system())
         exit(1)

###   #======================================================================================================================================
###   # EVERYTHING BELOW HERE IS OUR FIRST STAB AT THE QT INSTALLER.  CURRENT THINKING IS THAT WE'LL DELETE ALL THIS.
###   # Copy the generated installer and package configuration/information files from the build directory to where they
###   # belong in the qtIfw subtree
###   shutil.copy2(dir_build.joinpath('config.xml'),  dir_qtIfw_config)
###   shutil.copy2(dir_build.joinpath('package.xml'), dir_qtIfw_meta)
###
###   # Copy other files
###   shutil.copy2(dir_base.joinpath('packaging').joinpath('qtIfw').joinpath('installerPage1.ui'), dir_qtIfw_meta)
###   shutil.copy2(dir_base.joinpath('LICENSE'), dir_qtIfw_meta.joinpath('license.txt'))
###
###   CONFIG_INSTALLER_APPLICATION_ICON = os.environ.get('CONFIG_INSTALLER_APPLICATION_ICON')
###   if (CONFIG_INSTALLER_APPLICATION_ICON is not None and CONFIG_INSTALLER_APPLICATION_ICON != ""):
###      log.debug("Copying " + CONFIG_INSTALLER_APPLICATION_ICON)
###      shutil.copy2(
###         dir_base.joinpath(
###            os.environ['CONFIG_INSTALLER_APPLICATION_ICON_DIR']
###         ).joinpath(
###            CONFIG_INSTALLER_APPLICATION_ICON
###         ),
###         dir_qtIfw_meta
###      )
###
###   CONFIG_INSTALLER_WINDOW_ICON = os.environ.get('CONFIG_INSTALLER_WINDOW_ICON')
###   if (CONFIG_INSTALLER_WINDOW_ICON is not None and CONFIG_INSTALLER_WINDOW_ICON != ""):
###      shutil.copy2(
###         dir_base.joinpath(
###            os.environ['CONFIG_INSTALLER_WINDOW_ICON_DIR']
###         ).joinpath(
###            CONFIG_INSTALLER_WINDOW_ICON
###         ),
###         dir_qtIfw_meta
###      )
###
###   #
###   # Find the binarycreator (Mac and Linux) / binarycreator.exe (Windows) file
###   #
###   # In order of preference we want:
###   #   - Whatever is already first in the PATH
###   #   - If nothing is in the path, whatever the most recent version of Qt IFW is installed under the user's home
###   #     directory
###   # But if we can't find anything we want to capture that error and bail out
###   #
###   bcExtn = ""
###   if (platform.system() == 'Windows'):
###      bcExtn = ".exe"
###
###   log.debug('Looking for binarycreator' + bcExtn)
###   exe_binarycreator = shutil.which("binarycreator" + bcExtn)
###   if (exe_binarycreator is None or exe_binarycreator == ""):
###      localBcs = sorted(pathlib.Path.home().joinpath('Qt').glob('QtIFW-*/bin/binarycreator' + bcExtn))
###      if (len(localBcs) > 0):
###         exe_binarycreator = shutil.which(localBcs[len(localBcs) - 1])
###
###   if (exe_binarycreator is None or exe_binarycreator == ""):
###      log.critical('Could not locate Qt IFW binarycreator')
###      exit(1)
###
###   #
###   # On Windows we need the binary we're creating to have a ".exe" extension
###   #
###   # On Mac we want to specify a ".app" extension, which will also tell binarycreator to create a macOS application
###   # bundle
###   #
###   appExtn = ""
###   if (platform.system() == 'Windows'):
###      appExtn = ".exe"
###   elif (platform.system() == 'Darwin'):
###      appExtn = ".app"
###
###   log.debug("Running " + exe_binarycreator.as_posix())
###   os.chdir(dir_qtIfw)
###
###   abortOnRunFail(
###      subprocess.run(
###         [
###            exe_binarycreator,
###            '-v',
###            '-c', dir_qtIfw_config.joinpath('config.xml').as_posix(),
###            '-p', dir_qtIfw_packages.as_posix(),
###            os.environ['CONFIG_APPLICATION_NAME_UC'] + appExtn
###         ],
###         capture_output=False
###      )
###   )

   return

#-----------------------------------------------------------------------------------------------------------------------
# .:TBD:.  Let's see if we can do a .deb package
#-----------------------------------------------------------------------------------------------------------------------
def doDebianPackage():
   return

#-----------------------------------------------------------------------------------------------------------------------
# Act on command line arguments
#-----------------------------------------------------------------------------------------------------------------------
# See above for parsing
match args.subCommand:

   case 'setup':
      doSetup(setupOption = args.setupOption)

   case 'package':
      doPackage()

   # If we get here, it's a coding error as argparse should have already validated the command line arguments
   case _:
      log.error('Unrecognised command "' + command + '"')
      exit(1)
