#!/usr/bin/env python3
#-----------------------------------------------------------------------------------------------------------------------
# bt is part of Brewken, and is copyright the following authors 2022:
#   • Matt Young <mfsy@yahoo.com>
#
# Brewken is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Brewken is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# This build tool (bt) script helps with Git setup, meson build configuration and packaging.  It takes one argument, and
# does different things depending on what that argument is:
#
#    ./bt setup                  Sets up Git options and configures the 'mbuild' meson build directory
#
#    ./bt package                Does the packaging by running 'meson install' (with extra options to "install"
#                                binaries, data etc to a subdirectory of the build directory rather than to where they
#                                need to be for a local install) and 'meson compile part_2_of_packaging'.  The latter
#                                command ends up invoking this script again with part_3_of_packaging parameter.
#
#    ./bt part_3_of_packaging   Intended to be invoked from meson, this creates a distributable package, making use
#                                of various environment variables set in the meson.build file.
#
# The rationale for bt invoking meson invoking bt is to minimise the number of places we essentially create the same
# settings -- including keeping all the "what files need installing" config in the meson.build file.
#
#
#
# .:TODO:. At some point we should be able to retire:
#    configure
#    setupgit.sh
#    CMakeLists.txt
#    src/CMakeLists.txt
#    packaging/qtIfw -- if we end up not going with Qt Install Framework
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# Python modules we need to import
#-----------------------------------------------------------------------------------------------------------------------
import datetime
import logging
import os
import pathlib
import platform
import shutil
import subprocess
import sys

#-----------------------------------------------------------------------------------------------------------------------
# Global constants
#-----------------------------------------------------------------------------------------------------------------------
projectName = 'brewken'
capitalisedProjectName = projectName.capitalize()

#-----------------------------------------------------------------------------------------------------------------------
# Welcome banner and environment info
#-----------------------------------------------------------------------------------------------------------------------
# %c argument to strftime means "Locale’s appropriate date and time representation"
print(
   '⭐ ' + capitalisedProjectName + ' build tool running on ' + platform.system() + ' (' + platform.release() +
   ') at ' + datetime.datetime.now().strftime('%c') + ' ⭐'
)

#-----------------------------------------------------------------------------------------------------------------------
# Set up logging to stderr
#-----------------------------------------------------------------------------------------------------------------------
logging.basicConfig(format='%(message)s')
log = logging.getLogger(__name__)
# Normally we set INFO logging, but DEBUG is useful if you're actually working on this script
#log.setLevel(logging.INFO)
log.setLevel(logging.DEBUG)
# Include the log level in the message
handler = logging.StreamHandler()
handler.setFormatter(
#   logging.Formatter('{asctime} {name} {levelname:8s} {message}', style='{')
   logging.Formatter('{levelname:8s} {message}', style='{')
)
log.addHandler(handler)
# If we don't do this, everything gets printed twice
log.propagate = False

#-----------------------------------------------------------------------------------------------------------------------
# Note the working directory from which we were invoked -- though it shouldn't matter as we try to be independent of
# this
#-----------------------------------------------------------------------------------------------------------------------
log.debug('Working directory when invoked: ' + pathlib.Path.cwd().as_posix())

#-----------------------------------------------------------------------------------------------------------------------
# Directories
#-----------------------------------------------------------------------------------------------------------------------
dir_base          = pathlib.Path(__file__).parent.resolve()
dir_gitInfo       = dir_base.joinpath('.git')
dir_build         = dir_base.joinpath('mbuild')
dir_gitSubmodules = dir_base.joinpath('third-party')
# See comment in doPackage() for explanation of qtIfw directory tree
dir_qtIfw           = dir_build.joinpath('qtIfw')
dir_qtIfw_config    = dir_qtIfw.joinpath('config')
dir_qtIfw_packages  = dir_qtIfw.joinpath('packages')
dir_qtIfw_component = dir_qtIfw_packages.joinpath('com.' + projectName + '.root')
dir_qtIfw_data      = dir_qtIfw_component.joinpath('data')
dir_qtIfw_meta      = dir_qtIfw_component.joinpath('meta')
dirList_qtIfw = [
   dir_qtIfw          ,
   dir_qtIfw_config   ,
   dir_qtIfw_packages ,
   dir_qtIfw_component,
   dir_qtIfw_data     ,
   dir_qtIfw_meta     ,
]

#-----------------------------------------------------------------------------------------------------------------------
# External commands
#-----------------------------------------------------------------------------------------------------------------------
# Advice at https://docs.python.org/3/library/subprocess.html is "For maximum reliability, use a fully qualified path
# for the executable. To search for an unqualified name on PATH, use shutil.which()"
exe_git   = shutil.which("git")
exe_meson = shutil.which("meson")

#-----------------------------------------------------------------------------------------------------------------------
# Helper function for checking result of running external commands
#
# Given a CompletedProcess object returned from subprocess.run(), this checks the return code and, if it is non-zero
# stops this script with an error message and the same return code.  Otherwise control is returned to the caller.
#-----------------------------------------------------------------------------------------------------------------------
def abortOnRunFail(runResult: subprocess.CompletedProcess):
   if (runResult.returncode != 0):
      # According to https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess,
      # CompletedProcess.args (the arguments used to launch the process) "may be a list or a string", but its not clear
      # when it would be one or the other.
      if (isinstance(runResult.args, str)):
         log.critical('Error running ' + runResult.args)
      else:
         commandName = os.path.basename(runResult.args[0])
         log.critical('Error running ' + commandName + ' (' + ' '.join(str(ii) for ii in runResult.args) + ')')

      exit(runResult.returncode)

   return

#-----------------------------------------------------------------------------------------------------------------------
# Check Meson is installed
#-----------------------------------------------------------------------------------------------------------------------
if (exe_meson is None or exe_meson == ""):
   log.critical('Cannot find meson - please see https://mesonbuild.com/Getting-meson.html for how to install')
   exit(1)

#-----------------------------------------------------------------------------------------------------------------------
# Check Git is installed if its magic directory is present
#-----------------------------------------------------------------------------------------------------------------------
if (dir_gitInfo.is_dir()):
   log.debug('Found git information directory:' + dir_gitInfo.as_posix())
   if (exe_git is None or exe_git == ""):
      log.critical('Cannot find git - please see https://git-scm.com/downloads for how to install')
      exit(1)

#-----------------------------------------------------------------------------------------------------------------------
# Show command line help
#-----------------------------------------------------------------------------------------------------------------------
def printUsage():
   # We deliberately don't list the part_3_of_packaging command here because it's only supposed to be invoked from
   # meson as part of 'meson package' (which in turn is invoked from './bt package').
   print("Usage: bt <command>")
   print()
   print("Commands:")
   print("  help              Shows this message")
   print("  setup             Set up meson build directory (mbuild) and git options")
   print("  package           Build a distributable installer")
   return

#-----------------------------------------------------------------------------------------------------------------------
# ./bt setup
#-----------------------------------------------------------------------------------------------------------------------
def doSetup():
   # If this is a git checkout then let's set up git with the project standards
   if (dir_gitInfo.is_dir()):
      log.info('Setting up ' + capitalisedProjectName + ' git preferences')
      # Enforce indentation with spaces, not tabs.
      abortOnRunFail(
         subprocess.run(
            [exe_git,
               "config",
               "--file", dir_gitInfo.joinpath('config').as_posix(),
               "core.whitespace",
               "tabwidth=3,tab-in-indent"],
            capture_output=False
         )
      )

      # Enable the standard pre-commit hook that warns you about whitespace errors
      shutil.copy2(dir_gitInfo.joinpath('hooks/pre-commit.sample'),
                     dir_gitInfo.joinpath('hooks/pre-commit'))

      # When a git repository is cloned, the submodules don't get cloned until you specifically ask for it
      subprocess.run(['tree', dir_gitSubmodules.as_posix()])
      if (not dir_gitSubmodules.is_dir() or len(os.listdir(dir_gitSubmodules)) == 0):
         log.info('Pulling in submodules in ' + dir_gitSubmodules.as_posix())
         os.mkdir(dir_gitSubmodules)
         abortOnRunFail(subprocess.run([exe_git, "submodule", "init"], capture_output=False))
         abortOnRunFail(subprocess.run([exe_git, "submodule", "update"], capture_output=False))

   # Check whether Meson build directory is already set up.  (Although nothing bad happens, if you run setup twice,
   # it complains and tells you to run configure.)
   # Best clue that set-up has been run (rather than, say, user just created empty mbuild directory by hand) is the
   # presence of meson-info/meson-info.json (which is created by setup for IDE integration -- see
   # https://mesonbuild.com/IDE-integration.html#ide-integration)
   runMesonSetup = True
   warnAboutCurrentDirectory = False
   if (dir_build.joinpath('meson-info/meson-info.json').is_file()):
      log.info('Meson build directory ' + dir_build.as_posix() + ' appears to be already set up')
      # You usually only need to reset things after you've done certain edits to defaults etc in meson.build.  There
      # are a whole bunch of things you can control with the 'meson configure' command, but it's simplest in some ways
      # just to reset the build directory and rely on meson setup picking up defaults from meson.build.
      response = ""
      while (response != 'y' and response != 'n'):
         response = input('Do you want to completely reset the build directory? [y or n] ').lower()
      if (response == 'n'):
         runMesonSetup = False
      else:
         # It's very possible that the user's current working directory is mbuild.  If so, we need to warn them and move
         # up a directory (as 'meson setup' gets upset if current working directory does not exist).
         log.info('Removing existing Meson build directory ' + dir_build.as_posix())
         if (pathlib.Path.cwd().as_posix() == dir_build.as_posix()):
            # We write a warning out here for completeness, but we really need to show it further down as it will have
            # scrolled off the top of the terminal with all the output from 'meson setup'
            log.warning('You are currently in the directory we are about to delete.  You will need to change directory!')
            warnAboutCurrentDirectory = True
            os.chdir(dir_base)
         shutil.rmtree(dir_build)

   if (runMesonSetup):
      log.info('Setting up ' + dir_build.as_posix() + ' meson build directory')
      # See https://mesonbuild.com/Commands.html#setup for all the optional parameters to meson setup
      # Note that meson setup will create the build directory (along with various subdirectories)
      abortOnRunFail(subprocess.run([exe_meson, "setup", dir_build.as_posix(), dir_base.as_posix()],
                                    capture_output=False))

      log.info('Finished setting up Meson build.  Note that the warnings above about path separator and optimization ' +
               'level are expected!')

   if (warnAboutCurrentDirectory):
      print("❗❗❗ Your current directory has been deleted!  You need to run 'cd ../mbuild' ❗❗❗")
   log.debug('Setup done')
   print()
   print('You can now build, test, install and run ' + capitalisedProjectName + ' with the following commands:')
   if (warnAboutCurrentDirectory):
      print('   cd ../mbuild     [or cd ' + dir_build.as_posix() + ']')
   else:
      print('   cd mbuild     [or cd ' + dir_build.as_posix() + ']')
   print('   meson compile')
   print('   meson test')
   print('   meson install')
   print('   ' + projectName)


   return

#-----------------------------------------------------------------------------------------------------------------------
# ./bt package
#-----------------------------------------------------------------------------------------------------------------------
def doPackage():
   #
   # The directory structure we create inside the build directory (mbuild) for packaging is:
   #
   #    qtIfw/             <-- Groups all the Qt-IFW stuff together and keeps it separate from what's in the top-level
   #    │                      build directory.  The binary installer we generate ends up in this directory.
   #    │
   #    ├── config/        <-- Global configuration for the installer lives here.  (If needed, a single installer can
   #    │                      offer the end user choices about which packages (aka components) to install.  We don't
   #    │                      need that complexity, so we just have one package.)
   #    └── packages/
   #        │
   #        └── com.<appname>.root/  <-- Each subdirectory of packages is supposed to "act as domain-like identifier"
   #            │                        for a component or subcomponent of the software.  We use the application name
   #            │                        (ie brewtarget or brewken) for the "domain-like" bit.  We only have one
   #            │                        subdirectory as we're not offering the end user a choice about which bits of
   #            │                        functionality to install (otherwise each component and sub-component would also
   #            │                        have its own packages subdirectory, with names like
   #            │                        com.<appname>.root.component_foo.subcomponent_bar).
   #            │
   #            ├── data/            <-- Contains everything the installer is going to install, all packaged into
   #            │                        archive files.  Archive files can be 7z (the default), zip, tar.gz, tar.bz2 or
   #            │                        tar.xz.  Creation of the archive files can be done automatically by the Qt
   #            │                        tools (eg binarycreator) or beforehand (eg using the archivegen tool that is
   #            │                        delivered with the Qt Installer Framework) for more control.
   #            │
   #            └── meta/            <-- Files in here are not installed; they specify settings for deployment and the
   #                                     installation process.  "The directory must contain at least a package
   #                                     information file and all files that you refer to in the package information
   #                                     file, such as scripts, user interface files, and translations.
   #                                     TODO: think about localising the installer
   #
   # The six steps for creating a QtIFW installer are listed at
   # https://doc.qt.io/qtinstallerframework/ifw-creating-installers.html.  We actually do them in a different order than
   # listed because we don't want to duplicate things that meson can do automatically.  (Nor do we want to jump through
   # hoops trying to bend meson to do things it is not designed for.)
   #

   # Step 1 : Create a package directory for the installable components
   #          We'll make all the directories mentioned above and ensure they start out empty
   if (dir_qtIfw.is_dir()):
      log.info('Removing existing ' + dir_qtIfw.as_posix() + ' directory tree')
      shutil.rmtree(dir_qtIfw)
   for dirToCreate in dirList_qtIfw:
      log.info('Creating directory ' + dirToCreate.as_posix())
      os.makedirs(dirToCreate)

   # We change into the build directory.  This doesn't affect the caller (of this script) because we're a separate
   # sub-process from the (typically) shell that invoked us and we cannot change the parent process's working
   # directory.
   os.chdir(dir_build)
   log.debug('Working directory now ' + pathlib.Path.cwd().as_posix())
   #
   # Running 'meson install' with the --destdir option will put all the installable files (program executable,
   # translation files, data files, etc) in the packaging directory
   #
   # It also generates config.xml and package.xml, but does not put them in the right directory
   #
   log.info('Running meson install with --destdir option')
   # See https://mesonbuild.com/Commands.html#install for the optional parameters to meson install
   abortOnRunFail(subprocess.run([exe_meson, "install", "--destdir", dir_qtIfw_data.as_posix()],
                                 capture_output=False))

   #
   # If meson install worked, we can do the actual packaging via 'meson compile package'.  This will end up invoking
   # another instance of this script, but with the part_3_of_packaging parameter (and a whole bunch of useful
   # environment variables set by meson).
   #
   # Why is it 'meson compile package' rather than, say, 'meson package'?  It's because meson doesn't really know about
   # packaging and we're just running it to get build info.  So we have a custom meson target called 'package', and when
   # we ask meson to "compile" a custom target, we can actually have it run the executable of our choice - in this case
   # this script.
   #
   log.info('Running meson compile part_2_of_packaging')
   abortOnRunFail(subprocess.run([exe_meson, 'compile', 'part_2_of_packaging'], capture_output=False))

   print()
   return

#-----------------------------------------------------------------------------------------------------------------------
# ./bt part_3_of_packaging
#-----------------------------------------------------------------------------------------------------------------------
# NB: This part of the script is intended to be invoked from the Meson build (see ../meson.build).  Meson will
# automatically set the following environment variables for us (though we don't need them as we assume these are the
# directories we knew about when we invoked 'meson package').:
#    MESON_SOURCE_ROOT
#    MESON_BUILD_ROOT
# Additionally, we use meson.build to set a whole bunch of CONFIG_ environment variables
#-----------------------------------------------------------------------------------------------------------------------
def doMesonPackageHelper():
   # Copy the generated installer and package configuration/information files from the build directory to where they
   # belong in the qtIfw subtree
   shutil.copy2(dir_build.joinpath('config.xml'),  dir_qtIfw_config)
   shutil.copy2(dir_build.joinpath('package.xml'), dir_qtIfw_meta)

   # Copy other files
   shutil.copy2(dir_base.joinpath('packaging').joinpath('qtIfw').joinpath('installerPage1.ui'), dir_qtIfw_meta)
   shutil.copy2(dir_base.joinpath('LICENSE'), dir_qtIfw_meta.joinpath('license.txt'))

   CONFIG_INSTALLER_APPLICATION_ICON = os.environ.get('CONFIG_INSTALLER_APPLICATION_ICON')
   if (CONFIG_INSTALLER_APPLICATION_ICON is not None and CONFIG_INSTALLER_APPLICATION_ICON != ""):
      log.debug("Copying " + CONFIG_INSTALLER_APPLICATION_ICON)
      shutil.copy2(
         dir_base.joinpath(
            os.environ['CONFIG_INSTALLER_APPLICATION_ICON_DIR']
         ).joinpath(
            CONFIG_INSTALLER_APPLICATION_ICON
         ),
         dir_qtIfw_meta
      )

   CONFIG_INSTALLER_WINDOW_ICON = os.environ.get('CONFIG_INSTALLER_WINDOW_ICON')
   if (CONFIG_INSTALLER_WINDOW_ICON is not None and CONFIG_INSTALLER_WINDOW_ICON != ""):
      shutil.copy2(
         dir_base.joinpath(
            os.environ['CONFIG_INSTALLER_WINDOW_ICON_DIR']
         ).joinpath(
            CONFIG_INSTALLER_WINDOW_ICON
         ),
         dir_qtIfw_meta
      )

   #
   # Find the binarycreator (Mac and Linux) / binarycreator.exe (Windows) file
   #
   # In order of preference we want:
   #   - Whatever is already first in the PATH
   #   - If nothing is in the path, whatever the most recent version of Qt IFW is installed under the user's home directory
   # But if we can't find anything we want to capture that error and bail out
   #
   bcExtn = ""
   if (platform.system() == 'Windows'):
      bcExtn = ".exe"

   log.debug('Looking for binarycreator' + bcExtn)
   exe_binarycreator = shutil.which("binarycreator" + bcExtn)
   if (exe_binarycreator is None or exe_binarycreator == ""):
      localBcs = sorted(pathlib.Path.home().joinpath('Qt').glob('QtIFW-*/bin/binarycreator' + bcExtn))
      if (len(localBcs) > 0):
         exe_binarycreator = shutil.which(localBcs[len(localBcs) - 1])

   if (exe_binarycreator is None or exe_binarycreator == ""):
      log.critical('Could not locate Qt IFW binarycreator')
      exit(1)

   #
   # On Windows we need the binary we're creating to have a ".exe" extension
   #
   # On Mac we want to specify a ".app" extension, which will also tell binarycreator to create a macOS application
   # bundle
   #
   appExtn = ""
   if (platform.system() == 'Windows'):
      appExtn = ".exe"
   elif (platform.system() == 'Darwin'):
      appExtn = ".app"

   log.debug("Running " + exe_binarycreator.as_posix())
   os.chdir(dir_qtIfw)

   abortOnRunFail(
      subprocess.run(
         [
            exe_binarycreator,
            '-v',
            '-c', dir_qtIfw_config.joinpath('config.xml').as_posix(),
            '-p', dir_qtIfw_packages.as_posix(),
            os.environ['CONFIG_APPLICATION_NAME_UC'] + appExtn
         ],
         capture_output=False
      )
   )

   return

#-----------------------------------------------------------------------------------------------------------------------
# Process command line options
#-----------------------------------------------------------------------------------------------------------------------
numArgs = len(sys.argv) - 1
if (numArgs != 1):
   log.error('Wrong number of arguments')
   printUsage()
   exit(1)

command = sys.argv[1]
match command:
   case 'help':
      printUsage()

   case 'setup':
      doSetup()

   case 'package':
      doPackage()

   case 'part_3_of_packaging':
      doMesonPackageHelper()

   case _:
      log.error('Unrecognised command "' + command + '"')
      printUsage()
      exit(1)
